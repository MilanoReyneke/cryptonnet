{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "\n",
    "\n",
    "# A two layered neural network is used that takes 14 days worth of crypto-currency data\n",
    "class NeuralNet():\n",
    "     \n",
    "        \n",
    "    def __init__(self, layers=[14,10,1], learning_rate=0.1, iterations=10000):\n",
    "        self.params = {}\n",
    "        self.learning_rate = learning_rate\n",
    "        self.iterations = iterations\n",
    "        self.loss = []\n",
    "        self.sample_size = None\n",
    "        self.layers = layers\n",
    "        self.inputData = None\n",
    "        self.outputGoal = None\n",
    "                \n",
    "    def init_weights(self):\n",
    "        \n",
    "        np.random.seed(1) \n",
    "        self.params['W1'] = np.random.randn(self.layers[0], self.layers[1]) \n",
    "        self.params['b1'] = np.random.randn(self.layers[1],)\n",
    "        self.params['W2'] = np.random.randn(self.layers[1],self.layers[2]) \n",
    "        self.params['b2'] = np.random.randn(self.layers[2],)\n",
    "    \n",
    "    def relu(self,Z):\n",
    "       \n",
    "        return np.maximum(0,Z)\n",
    "\n",
    "    def dRelu(self, x):\n",
    "        x[x<=0] = 0\n",
    "        x[x>0] = 1\n",
    "        return x\n",
    "\n",
    "\n",
    "    def sigmoid(self,Z):\n",
    "        \n",
    "        return 1/(1+np.exp(-Z))\n",
    "\n",
    "    def lossfunc(self,y, yhat):\n",
    "    \n",
    "        # a difference squared loss function is used for this net\n",
    "        lossf = (y-yhat)**2\n",
    "        \n",
    "    \n",
    "        return lossf\n",
    "\n",
    "    def forward_propagation(self):\n",
    "        \n",
    "        \n",
    "        Z1 = np.dot(self.inputData, self.params['W1'] ) + self.params['b1']\n",
    "        A1 = self.relu(Z1)\n",
    "        Z2 = np.dot(A1, self.params['W2'],) + self.params['b2']\n",
    "        yhat = self.sigmoid(Z2)\n",
    "        loss = self.lossfunc(self.outputGoal,yhat)\n",
    "\n",
    "        # save calculated parameters     \n",
    "        self.params['Z1'] = Z1\n",
    "        self.params['Z2'] = Z2\n",
    "        self.params['A1'] = A1\n",
    "\n",
    "        return yhat,loss\n",
    "\n",
    "    def back_propagation(self,yhat):\n",
    "        \n",
    "        # derivatives from the loss function calculated\n",
    "        y_inv = 1 - self.outputGoal\n",
    "        yhat_inv = 1 - yhat\n",
    "\n",
    "        \n",
    "        dl_wrt_yhat = -2*(self.outputGoal-yhat)\n",
    "        dl_wrt_sig = yhat * (yhat_inv)\n",
    "        dl_wrt_z2 = dl_wrt_yhat * dl_wrt_sig\n",
    "\n",
    "        dl_wrt_A1 = np.dot(dl_wrt_z2, self.params['W2'].T)\n",
    "        dl_wrt_w2 = dl_wrt_z2*self.params['A1'].T\n",
    "        dl_wrt_b2 = np.sum(dl_wrt_z2, axis=0, keepdims=True)\n",
    "\n",
    "        dl_wrt_z1 = np.dot(dl_wrt_A1, self.dRelu(self.params['Z1']))\n",
    "        dl_wrt_w1 = np.dot(dl_wrt_z1,self.inputData.T)\n",
    "        dl_wrt_b1 = np.sum(dl_wrt_z1, axis=0, keepdims=True)\n",
    "\n",
    "        #update the weights and bias\n",
    "\n",
    "        \n",
    "        self.params['W1'] = (self.params['W1'].transpose() - (self.learning_rate * dl_wrt_w1)).transpose()\n",
    "        self.params['W2'] = (self.params['W2'].transpose() - (self.learning_rate * dl_wrt_w2)).transpose()\n",
    "        self.params['b1'] = self.params['b1'] - self.learning_rate * dl_wrt_b1\n",
    "        self.params['b2'] = self.params['b2'] - self.learning_rate * dl_wrt_b2\n",
    "\n",
    "    def fit(self, X, y):\n",
    "        # trains the neural net with input data, X, and goal output, y \n",
    "        self.inputData = X\n",
    "        self.outputGoal = y\n",
    "        self.init_weights() #initialize weights and bias\n",
    "\n",
    "\n",
    "        for i in range(self.iterations):\n",
    "            yhat, loss = self.forward_propagation()\n",
    "            self.back_propagation(yhat)\n",
    "            self.loss.append(loss)\n",
    "\n",
    "    def predict(self, X):\n",
    "        #neural net's prediction based on input, X\n",
    "        Z1 = np.dot(X, self.params['W1']) + self.params['b1']\n",
    "        A1 = self.relu(Z1)\n",
    "        Z2 = np.dot(A1, self.params['W2']) + self.params['b2']\n",
    "        p = self.sigmoid(Z2)\n",
    "        if p > 0.5:\n",
    "            pred= \"Crypto closing price for the day will increase\"\n",
    "        else:\n",
    "            pred = \"Crypto closing price for the day will decrease\"\n",
    "        return pred "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {},
   "outputs": [],
   "source": [
    "# instantiate neural net\n",
    "Net = NeuralNet()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {},
   "outputs": [],
   "source": [
    "import csv \n",
    "import pandas as pd\n",
    "\n",
    "# Extracting and organising data to train and test neural net\n",
    "\n",
    "\n",
    "head = [ 'Unix Timestamp','Date', 'Symbol','Open','High','Low','Close','Volume BTC','Volume USD']\n",
    "\n",
    "coin_data = pd.read_csv('/Users/milanoreyneke/Downloads/HitBTC_BTCUSD_d.csv', sep=',', names=head)\n",
    "coin_data\n",
    "\n",
    "\n",
    "difference = coin_data['Open'] - coin_data['Close']\n",
    "\n",
    "for i in range(len(difference)):\n",
    "    if difference[i] > 0:\n",
    "        difference[i] = 1\n",
    "    else:\n",
    "        difference[i] = 0\n",
    "        \n",
    "\n",
    "twoWeekData = []\n",
    "totalData = []\n",
    "for i in range(26):\n",
    "    for j in range(14):\n",
    "        twoWeekData.append((coin_data['Open'][14*i + j]/100)) # dividing all data by 100 to prevent stack overflow\n",
    "        totalData.append(twoWeekData)\n",
    "    twoWeekData = []\n",
    "    \n",
    "    \n",
    "twoWeekDiff = []\n",
    "for i in range(26):\n",
    "    twoWeekDiff.append(difference[14*i])\n",
    "    \n",
    "# crypto-currency prices training data \n",
    "trainData = list(zip(totalData, twoWeekDiff))          "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Training the net with crypto-currency data\n",
    "\n",
    "for i in range(len(trainData)):\n",
    "    inputD = np.array(trainData[i][0])\n",
    "    goal = trainData[i][1]\n",
    "    Net.fit(inputD, goal)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'Crypto closing price for the day will decrease'"
      ]
     },
     "execution_count": 67,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Testing net on data from the training set\n",
    "\n",
    "Net.predict(trainData[0][0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
